# ADR-003: Event Sourcing no PostgreSQL

## Status
Aprovado

## Contexto
O desafio exige auditabilidade total: saber quem alterou qual dado e quando.
A solução deve manter um histórico imutável de todas as mudanças realizadas
no agregado `Customer` (Cliente).

Foi avaliado inicialmente o uso do Outbox Pattern, porém foi descartado após
análise do escopo real do problema (ver seção de decisão).

## O que é Event Sourcing?
Em vez de persistir apenas o estado atual de um registro, cada mudança é
gravada como um evento imutável e ordenado cronologicamente. O estado atual
é derivado relendo os eventos desde o início, ou mantido em uma tabela de
leitura (read model / projeção) atualizada a cada novo evento.


## Decisão
Event Sourcing com Event Store implementado no próprio PostgreSQL (Vide [ADR-001]())


## Estrutura das Tabelas

```sql
-- Event Store: histórico imutável de todos os eventos do agregado Cliente
CREATE TABLE customer_events (
    id           UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
    aggregate_id UUID        NOT NULL,           -- ID do Cliente
    event_type   VARCHAR(100) NOT NULL,          -- ex: "ClienteCriado"
    payload      JSONB       NOT NULL,           -- dados alterados
    occurred_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by   VARCHAR(255) NOT NULL           -- claim "sub" do token
);

-- Read Model: estado atual projetado a partir dos eventos
CREATE TABLE customers (
    id           UUID        PRIMARY KEY,
    documento    VARCHAR(18) NOT NULL UNIQUE,
    email        VARCHAR(255) NOT NULL UNIQUE,
    nome         VARCHAR(255) NOT NULL,
    -- demais campos...
);
```
## Fluxo de Escrita
```
Command (ex: AtualizarClienteCommand)
    │
    ▼
Handler executa e valida regras de negócio
    │
    ▼
Transação única no PostgreSQL:
    ├─► UPSERT em customers        (read model / estado atual)
    └─► INSERT em customer_events  (Event Store / auditoria)
    
Consistência garantida pelo próprio banco — sem worker, sem complexidade extra.

```

> [!NOTE]  
> ### Não há o dilema dual-write neste cenário?
> O dual-write é um problema quando se precisa gravar em um banco de dados **e**
> publicar em um sistema externo (ex: message broker) de forma atômica. Neste
> desafio, os dois destinos de escrita — `customers` (read model) e
> `customer_events` (Event Store) — são tabelas no **mesmo banco PostgreSQL**.
> Uma única transação ACID já garante que ambas as gravações ocorrem juntas ou
> nenhuma ocorre. Não há sistema externo envolvido, portanto não há dual-write
> e padrão como o Outbox não se aplica.
> 
> O Outbox Pattern seria necessário apenas se o sistema precisasse notificar
> módulos externos (ex: faturamento via RabbitMQ) ao cadastrar um cliente.
> Nesse cenário futuro, o padrão poderia ser introduzido sem muitos impactos na 
> arquitetura atual.

### Consequências
- Histórico 100% imutável e auditável — quem alterou, o quê e quando
- Consistência garantida pela transação ACID — sem risco de inconsistência
- Nenhum componente adicional (worker, fila) necessário neste escopo
- A tabela `customer_events` cresce apenas com INSERTs — nunca UPDATE ou DELETE
- Escalabilidade futura: se mensageria for necessária, o Outbox Pattern pode ser 
  adicionado sem reescrever a lógica de domínio.

